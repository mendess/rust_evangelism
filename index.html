<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Rust Evangelism</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black2.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/gruvbox-dark.css"
      id="highlight-theme">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1 class="title">Rust Evangelism</h1>
          <p class="subtitle">
          <img
            style='vertical-align:middle;'
            src="img/rust.png"
            alt="C"
            height="150em"/>
          </p>
          <p class="author">Mendes</p>
          <img
            style='vertical-align:middle;'
            src="img/ferris.png"
            alt="C"
            height="80em"/>
        </section>
        <section>
          <h1>What is Rust?</h1>
          <section>
            Rust is a <em>systems programming language</em>, this means it allows
            low level control of the hardware and system resourses.
            <br>
            The two most <em>in</em>famous languages in this field are
            <img
              style='vertical-align:middle;'
              src="img/c.png"
              alt="C"
              height="40em"/>
            and
            <img
              style='vertical-align:middle;'
              src="img/cpp.png"
              alt="C++"
              height="40em"/>.
          </section>
          <section>
            <h3>Why make a new language?</h3>

            <img style='vertical-align:middle;' src="img/c.png" alt="C" height="40em"/>,
            <img style='vertical-align:middle;' src="img/cpp.png" alt="C++" height="40em"/>
            are languages that give you a lot of power and control to their users, but...
            <div class="fragment">
              <blockquote>
                With great power, comes great responsibility
              </blockquote>
              <p style="text-align: right"> ‚Äì Spider Man probably</p>
            </div>
          </section>
          <section>
            And what is the main dificulty when working with this languages?
            <span class="fragment">Memory safety</span>

            <pre class="fragment"> Segmentation fault (core dumped) </pre>

            <span class="fragment">What if we could make a language where a
              segmentation fault doesn't compile?</span>
          </section>
        </section>
        <section>
          <h1>Ownership</h1>
          <section>
            <em>Ownership</em> is one of the <em>mental models</em> that we can use
            the avoid a whole class of bugs like "double free" or "use after free".

            <div class="fragment">
              Rust is not garbage collected so we can turn to ownership to answer the question
              "Who is responsible for freeing a particular block of memory?"
            </div>
          </section>
          <section data-auto-animate>
            Let's start by making a simple dynamic array in
            <img
              style='vertical-align:middle;'
              src="img/c.png"
              alt="C"
              height="40em"/>

            <pre class="lang-c" data-id="code-animation"><code data-trim>
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;
            </code></pre>
            <ul>
              <li> <b>values</b>: Has a pointer to the integers we are storing</li>
              <li> <b>used</b>: Is how many elements are being stored right now. </li>
              <li> <b>capacity</b>: How much space exists in values. If
                <b>used</b> == <b>capacity</b> we need to grow <b>values</b>
              </li>
            </ul>
            <aside class="notes">
              Para vermos este conceito em a√ß√£o vamos escrever um pouco de C
              onde estas garantias n√£o existem.
            </aside>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers="7-11|7-13|7-17|7-19|1-20">
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;

IntVec int_vec_make(size_t initial_cap) {
  return (IntVec) {.capacity = initial_cap,
                   .used = 0,
                   .values = malloc(sizeof(int) * initial_cap)};
}

void int_vec_drop(IntVec a) { free(a.values); }

int main(void) {
    // a owns the memory
    IntVec a = int_vec_make(5);
    // a's memory is dropped/freed
    int_array_drop(a);
}
            </code></pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers="12-13|12-15|12-17">
IntVec int_vec_make(size_t initial_cap) {
  return (IntVec) {.capacity = initial_cap,
                   .used = 0,
                   .values = malloc(sizeof(int) * initial_cap)};
}

void int_vec_drop(IntVec a) { free(a.values); }

int main(void) {
    // a owns the memory
    IntVec a = int_vec_make(5);
    // oh no, now both a and b "own" the memory?
    IntVec b = a;
    // a's memory is dropped/freed
    int_vec_drop(a);
    // use after free because there were two "owners"
    printf("%d\n", b.values[1]);
}
            </code></pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <pre class="lang-c" data-id="code-animation"><code data-trim data-line-numbers="1-17">
IntVec int_vec_make(size_t initial_cap) {
  return (IntVec) {.capacity = initial_cap,
                   .used = 0,
                   .values = malloc(sizeof(int) * initial_cap)};
}

void int_vec_drop(IntVec a) { free(a.values); }

int main(void) {
    // a owns the memory
    IntVec a = int_vec_make(5);
    // oh no, now both a and b "own" the memory?
    IntVec b = a;
    // a's memory is dropped/freed
    int_vec_drop(a);
    // use after free because there were two "owners"
    printf("%d\n", b.values[1]);
}
            </code></pre>
            <aside class="notes">
              That didn't go so well, let's see how rust can stop this from happening.
            </aside>
          </section>
          <section data-auto-animate>
            Let's start from the same code.
            <br>
            The dynamic array in rust is called a vector and is already implemented.
            <pre class="lang-rust" data-id="code-animation">
              <code style="text-align: center; font-size: 28px">
Vec&lt;i32&gt;
              </code>
            </pre>

            <aside class="notes">
              It's a pointer, capacity, and used.
            </aside>
            <br>
          </section>
          <section data-auto-animate>
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="2-3|4-5|1-6">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // a's memory is dropped
                  drop(a);
                }
              </code>
            </pre>
            <aside class="notes">
              Explicar syntax
            </aside>
          </section>
          <section data-auto-animate>
            Now let's try to create the same error.
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="4-5|4-7|4-9">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // Move a --to--&gt; b
                  let b = a;
                  // a's memory is dropped
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
            </pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <div class="r-stack">
              <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="1-10">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // Move a --to--&gt; b
                  let b = a;
                  // a's memory is dropped
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
              </pre>
              <img src="img/use_after_move.png" />
            </div>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="1-10">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // Move a --to--&gt; b
                  let b = a;
                  // a doesn't own the memory anymore and is 'uninitialized'
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
            </pre>
            <img src="img/use_after_move.png" />
          </section>
          <section>
            <div style="text-align: left">
              <h4 class="fragment" data-fragment-index="1"> How does ownership prevent "double free" and "use after free" bugs ?  </h4>
              <h4 class="fragment" data-fragment-index="2"> Double free </h4>
              <div class="fragment" data-fragment-index="3">
                <ul>
                  <li> For each block of memory the is only ever one owner </li>
                  <li> And only this one owner can free it's memory </li>
                </ul>
              </div>
            </div>
            <br>
            <div style="text-align: left">
              <h4 class="fragment" data-fragment-index="4"> Use after free </h4>
              <div class="fragment" data-fragment-index="5">
                Every time ownership of a variable is passed to a new variable, the previous variable becomes <em>uninitialized</em> and the compiler won't let you use it.
              </div>
            </div>
          </section>
        </section>
        <section>
          <h1>Lifetimes</h1>
          <section>
            <p class="fragment">
            Now, you might be thinking..
            <br>
            ..what if I want to share the same object in various parts of my code?
            </p>
            <p class="fragment">
            Pointers?
            </p>
            <p class="fragment">
            But pointers are scary :(
            </p>
            <p class="fragment">
              Having pointers means we can have <em>dangling</em> pointers.
            </p>
            <aside class="notes">
              <p>
              Mas <em>ownership</em> sozinha n√£o chega para criar uma linguagem
              us√°vel. √Ås vezes √© necess√°rio partilhar um objecto por varias
              partes do nosso c√≥digo.
              </p>
              <p>
              Mas se o pointer existir mais tempo que objecto para que aponta,
              temos um "use after free", aka, um dangling pointer.
              </p>
            </aside>
          </section>
          <section>
            <span class="fragment">
              <b>Lifetime:</b> Span of the program where an object is live.
            </span>
            <br>
            <br>
            <br>
            <span class="fragment">
              So the fix is """simple""", a pointer can only exist for as long as the object it
              points to exists.
            </span>
          </section>
          <section>
            And we already have language constructs for this: <tt>{}</tt>.
            Curlies tell us for how long an object lives.
            <div class="r-stack fragment">
              <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers>
              <script type="text/template">
                int foo() {
                  int* i; // lifetime of i starts here
                  {
                    int x = 42; // lifetime of x starts here
                    i = &x;
                  } // lifetime of x ends here
                  return *i;
                } // lifetime of i ends here
              </script>
              </code>
              </pre>
              <pre class="lang-c fragment" data-id="code-animation">
              <code data-trim data-line-numbers>
              <script type="text/template">
                int foo() {
                  int* i;       // 'i
                  {             // 'i
                    int x = 42; // 'i 'x
                    i = &x;     // 'i 'x
                  }             // 'i
                  return *i;    // 'i
                }
              </script>
              </code>
              </pre>
              <pre class="lang-c fragment" data-id="code-animation">
              <code data-trim data-line-numbers>
              <script type="text/template">
                int foo() {
                  int* i;
                  {
                    int x = 42;
                    i = &x;
                  }
                  return *i; // Undefined behaviour
                }
              </script>
              </code>
              </pre>
            </div>
          </section>
          <section>
            <h3>Undefined Behaviour</h3>
            <p>
              Undefined behaviour is when the behaviour of your program is impossible to define. In
              these situations the compiler is free to change your program in any way it sees fit, since
              it can assume that UB does not happen.
            </p>

            <div class="fragment">
              <p>
              For example, in <tt>gcc version 10.2.0</tt> compiling the previous program
              , with <tt>-O2</tt> optimizations, results in this assembly for function <tt>foo</tt>.
              </p>
              <pre class="lang-asm">
            <code data-trim>
            xor %eax,%eax
            retq
              </code></pre>
            </div>
            <aside class="notes">
              But this can get even worse! Let's see another example.
            </aside>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers>
              <script type="text/template">
                int* foo() {
                  int a[] = {1,2,3}; // lifetime of `a` starts
                  return a;
                } // lifetime of `a` ends
                int main() {
                  int a = foo();
                  printf("%d,%d,%d\n", a[0], a[1], a[2]);
                }
              </script>
              </code>
            </pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers>
              <script type="text/template">
                int* foo() {
                  int a[] = {1,2,3}; // lifetime of `a` starts
                  return a;
                } // lifetime of `a` ends
                int main() {
                  int a = foo();
                  printf("%d,%d,%d\n", a[0], a[1], a[2]);
                }
              </script>
              </code>
            </pre>
            <pre class="lang-asm" data-id="code-animation">
              <code data-trim>
              &lt;foo&gt;:
                xor %eax,%eax
                retq
              </code>
            </pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers>
              <script type="text/template">
                int* foo() {
                  int a[] = {1,2,3}; // lifetime of `a` starts
                  return a;
                } // lifetime of `a` ends
                int main() {
                  int a = foo();
                  printf("%d,%d,%d\n", a[0], a[1], a[2]);
                }
              </script>
              </code>
            </pre>
            <pre class="lang-asm" data-id="code-animation">
              <code data-trim>
              &lt;foo&gt;:
                xor %eax,%eax
                retq
              &lt;main&gt;:
                mov 0x0,%eax
                ud2
              </code>
            </pre>
            <a class="fragment"
               href="https://www.felixcloutier.com/x86/ud">? ud2 ?</a>
            <aside class="notes">
              ud2 is an invalid machine instruction, in a way it's a hardcoded
              Segmentation Fault. As you can see the compiler can do what it pleases
              when it encounters UB.

              And again, this is a bug rust just won't allow for.
            </aside>
          </section>
          <section data-auto-animate>
            <pre class="lang-rust">
              <code data-trim data-line-numbers>
              <script type="text/template">
                fn main() {
                  let i;
                  {
                    let x = 42;
                    i = &x;
                  }
                  println!("{}", *i);
                }
              </script>
              </code>
            </pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-rust">
              <code data-trim data-line-numbers>
              <script type="text/template">
                fn main() {
                  let i;
                  {
                    let x = 42;
                    i = &x;
                  }
                  println!("{}", *i);
                }
              </script>
              </code>
            </pre>
            <img src="img/lifetimes0.png"/>
          </section>
        </section>
        <section>
          <h1>Borrowing</h1>
          <section>
            In Rust a reference is usually called a
            <em>borrow</em>.
            <br>
            <br>
            <br>
            Some variables own things, and some borrow things.

            <p class="fragment">And as we all know, it's considered
              <em>rude</em> to ruin (drop) something we borrowed</p>
            <aside class="notes">
              E quando se empresta algo √© m√° educa√ß√£o estragar o que pedimos
              emprestado.
            </aside>
          </section>
          <section>
            <h4>There are 2 of borrows in Rust:</h4>
            <ul>
              <li class="fragment" >
                <b style="color: yellow">shared</b> (or <b>immutable</b>)
              </li>
              <li class="fragment">
                <b style="color: red">exclusive</b> (or <b>mutable</b>)
              </li>
            </ul>
          </section>
          <section>
            <h4>And there are 2 rules for these:</h4>
            <p class="fragment" style="text-align: left">At any point in the program...  </p>
            <ul>
              <li class="fragment">
                ... there can be any number of <b style="color: yellow">shared borrows</b> to any one object
                and no <b style="color: red">exclusive borrows</b>.
              </li>
              <li class="fragment">
                ... if there is an <b style="color: red">exclusive borrow</b> to an object, no other <em>borrow</em>,
                of any kind, can exist simultaneously.
              </li>
            </ul>
            <br/>
            <br/>
            <em class="fragment">oh, would you look at that, we just got thread safety for free</em>
            <aside class="notes">
              Mas isto √© muito abstrato, vamos ver um exemplo na nossa trusty C
              language.
            </aside>
          </section>
          <section data-auto-animate>
            Let's see a new example with our dynamic array.

            <pre class="lang-c" data-id="code-animation"><code data-trim>
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;
            </code></pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers="1-17|7-9|7-11|7-13|7-16|1-17">
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;

void int_vec_push(IntVec* self, int value) {
  // If the vector is full
  if(self->capacity == self->used) {
    // We double the capacity
    self->capacity = self->capacity ? self->capacity * 2 : 1;
    // Realocate the array, doubling the capacity.
    self->values = realloc(self->values, sizeof(int) * self->capacity);
  }
  // Add a new value to the vector
  self->values[self->used++] = value;
}
            </code></pre>
            <p class="fragment">
            The most important line in this code is line 13. In this line we can see
            that the pointer <code>self->values</code> is being reassigned!
            </p>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers="6|6-9|6-12|6-15|6-18|1-19">
typedef struct { int* values; size_t capacity, used; } IntVec;

void int_vec_push(IntVec* self, int value);

int main(void) {
  IntVec v = int_vec_make(0);

  // Push a new value
  int_vec_push(&v, 1); // this reallocates because capacity(0) == used(0)

  // create a pointer to the first value of the vector
  int* first_value_ptr = &v.values[0];

  // Push a new value
  int_vec_push(&v, 2); // capacity(1) == used(1) so we realocate

  // We try to mutate the first value of the vector
  *first_value_ptr = 42;
}
            </code></pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers="1-19">
typedef struct { int* values; size_t capacity, used; } IntVec;

void int_vec_push(IntVec* self, int value);

int main(void) {
  IntVec v = int_vec_make(0);

  // Push a new value
  int_vec_push(&v, 1); // this reallocates because capacity(0) == used(0)

  // create a pointer to the first value of the vector
  int* first_value_ptr = &v.values[0];

  // Push a new value
  int_vec_push(&v, 2); // capacity(1) == used(1) so we realocate

  // We try to mutate the first value of the vector
  *first_value_ptr = 42; // üî•
}
            </code></pre>
            <aside class="notes">
              Como podemos ver o <code>first_value_ptr</code> passa a ser um
              dangling pointer depois da linha 12, e quando tentamos utiliz√°-lo
              mais a frente o nosso programa crasha.
            </aside>
          </section>
          <section data-auto-animate>
            <pre class="lang-rust" data-id="code-animation">
            <code data-trim data-line-numbers="2|2-5|2-8|2-11|2-14|1-15">
            fn main() {
              let mut v = Vec::new();

              // Push a new value
              v.push(1);

              // create a pointer to the first value of the vector
              let first_value_ptr = &mut v[0];

              // Push a new value
              v.push(2);

              // We try to mutate the first value of the vector
              *first_value_ptr = 42;
            }
            </code></pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <div class="r-stack">
              <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="1-15">
            fn main() {
              let mut v = Vec::new();

              // Push a new value
              v.push(1);

              // create a pointer to the first value of the vector
              let first_value_ptr = &mut v[0];

              // Push a new value
              v.push(2);

              // We try to mutate the first value of the vector
              *first_value_ptr = 42;
            }
            </code>
              </pre>
              <img src="img/multiple_mutable_borrows.png" />
            </div>
          </section>
          <section data-auto-animate>
            <div class="r-stack">
              <div style="width:100%">
                <pre class="lang-rust" data-id="code-animation">
                  <code data-trim data-line-numbers="1-11">
            fn main() {
              let mut v = Vec::new();
              // Push a new value
              v.push(1);
              // create a pointer to the first value of the vector
              let first_value_ptr = &mut v[0];
              // Push a new value
              v.push(2);
              // We try to mutate the first value of the vector
              *first_value_ptr = 42;
            }
            </code>
                </pre>
                <img src="img/multiple_mutable_borrows_short.png" />
              </div>
              <img class="fragment" src="img/vec_push_signature.png"/>
            </div>
            <aside class="notes">
              Memory corruption
            </aside>
          </section>
          <section data-auto-animate>
            <div class="r-stack">
              <div style="width:100%">
                <pre class="lang-rust" data-id="code-animation">
                  <code data-trim data-line-numbers="1-11">
            fn main() {
              let mut v = Vec::new();
              // Push a new value
              v.push(1);
              // create a pointer to the first value of the vector
              let first_value_ptr = &mut v[0];
              // Push a new value
              v.push(2);
              // We try to mutate the first value of the vector
              *first_value_ptr = 42;
            }
            </code>
                </pre>
                <img src="img/multiple_mutable_borrows_short.png" />
              </div>
              <img src="img/vec_push_signature.png"/>
            </div>
            <aside class="notes">
              Memory corruption
            </aside>
          </section>
        </section>
        <section data-autoslide="1000" data-auto-animate>
          <h1>And lot's more...</h1>
          <p class="fragment"><a href="https://blog.rust-lang.org/2015/05/11/traits.html">Zero cost abstractions</a></p>
          <p class="fragment"><a href="https://doc.rust-lang.org/stable/book/ch13-02-iterators.html">Iterators</a></p>
          <p class="fragment"><a href="https://doc.rust-lang.org/stable/book/ch16-00-concurrency.html">Safe concurrency</a></p>
          <p class="fragment"><a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">Zero Sized Types</a></p>
          <p class="fragment"><a href="https://doc.rust-lang.org/stable/book/ch10-02-traits.html">Traits</a></p>
          <p class="fragment"><a href="https://doc.rust-lang.org/stable/book/ch06-01-defining-an-enum.html">Tagged unions/Sum types/Enums</a></p>
          <p class="fragment"><a href="https://doc.rust-lang.org/stable/book/ch18-00-patterns.html#patterns-and-matching">Pattern Matching</a></p>
          <p class="fragment">
          <img style="vertical-align:middle;" src="https://cdn.discordapp.com/attachments/411615726739390464/992012592061087744/unknown.png" height="40em"/>
          <a href="https://doc.rust-lang.org/nomicon/index.html"><em><b>Unsafe</b></em></a>
          </p>
        </section>
        <section data-autoslide="1000" data-auto-animate>
          <h1>And lot's more...</h1>
          <div style="display: flex">
            <div>
              <p><a href="https://blog.rust-lang.org/2015/05/11/traits.html">Zero cost abstractions</a></p>
              <p><a href="https://doc.rust-lang.org/stable/book/ch13-02-iterators.html">Iterators</a></p>
              <p><a href="https://doc.rust-lang.org/stable/book/ch16-00-concurrency.html">Safe concurrency</a></p>
              <p><a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">Zero Sized Types</a></p>
              <p><a href="https://doc.rust-lang.org/stable/book/ch10-02-traits.html">Traits</a></p>
              <p><a href="https://doc.rust-lang.org/stable/book/ch06-01-defining-an-enum.html">Tagged unions/Sum types/Enums</a></p>
              <p><a href="https://doc.rust-lang.org/stable/book/ch18-00-patterns.html#patterns-and-matching">Pattern Matching</a></p>
              <p>
              <img style="vertical-align:middle;" src="https://cdn.discordapp.com/attachments/411615726739390464/992012592061087744/unknown.png" height="40em"/>
              <a href="https://doc.rust-lang.org/nomicon/index.html"><em><b>Unsafe</b></em></a>
              </p>
            </div>
            <div style="margin-left: 3em">
              <p><a href="https://doc.rust-lang.org/stable/book/">The Rust Book</a></p>
              <img height="400em" src="img/the_book.jpg" />
            </div>
          </div>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
              hash: true,
              // Learn about plugins: https://revealjs.com/plugins/
              plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
            });
    </script>
  </body>
</html>
