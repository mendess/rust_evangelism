<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Rust Evangelism</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black2.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/gruvbox-dark.css" id="highlight-theme">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1 class="title">Rust Evangelism</h1>
          <p class="subtitle">ü¶Ä</p>
          <p class="author">Pedro Mendes</p>
        </section>
        <section data-markdown>
          <textarea data-template>
            # _disclaimer_

            Esta talk n√£o √© um tutorial de Rust!

            Esta talk √© eu a falar das partes que eu mais gosto da linguagem para mostrar o
            que √© Rust and _what is the hype all about_.

          </textarea>
        </section>
        <section>
          <h1>O que √© Rust?</h1>
          <section data-markdown>
            <textarea data-template>
              Rust √© uma _systems programming language_, isto quer dizer que √© uma linguagem que
              permite ter um controlo de baixo n√≠vel do hardware e recursos da m√°quina.

              As duas linguagens mais conhecidas neste campo s√£o C e C++.
            </textarea>
          </section>
          <section>
            <h2>Porqu√™ fazer uma linguagem nova</h2>

            C, C++ s√£o linguagens que d√£o muito poder e controlo a quem as usa, deixam
            controlar todos os detalhes. Mas...
            <div class="fragment">
              <blockquote>With great power, comes great responsibility</blockquote>
              <p style="text-align: right"> ‚Äì Spider Man probably</p>
            </div>
          </section>
        </section>
        <section>
          <h1>Ownership</h1>
          <section>
            Qual √© o principal dificuldade de trabalhar com estas linguagens?
            <span class="fragment">Gest√£o de mem√≥ria.</span>

            <div class="fragment">
              Quem √© aqui adora esta mensagem de erro?
              <pre> Segmentation fault (core dumped) </pre>
            </div>
            <div class="fragment">
              E se houvesse uma linguagem em que n√£o e poss√≠vel* compilar sequer c√≥digo que
              pode dar segmentation fault?
            </div>

            <div class="fragment"><em>mas como?</em></div>

          </section>
          <section data-markdown>
            <textarea data-template>
              _Ownership_ √© um dos _mental models_ que podemos utilizar para conseguir evitar
              um conjunto de bugs como "double free" ou "use after free"

              Podemos ver _ownership_ como uma forma de responder √† pergunta:
              "Quem √© respons√°vel por libertar esta mem√≥ria?"

              Vamos come√ßar com C para ilustrar isto.
            </textarea>
          </section>
          <section data-auto-animate>
            Vamos fazer algo simples, um array est√°tico.

            <pre class="lang-c" data-id="code-animation"><code data-trim>
typedef struct {
    int* values;
    size_t length;
} IntArray;
            </code></pre>
            <ul>
              <li> <b>values</b>: Tem um pointer para os valores que o array guarda.</li>
              <li> <b>length</b>: E quantos elementos tem. </li>
            </ul>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers="6-9|6-11|6-15|6-17|1-1000">
typedef struct {
    int* values;
    size_t length;
} IntArray;

IntArray int_array_make(size_t length) {
  return (IntArray) {.length = length,
                     .values = calloc(sizeof(int), length)};
}

void int_array_drop(IntArray a) { free(a.values); }

int main(void) {
    // a owns the memory
    IntArray a = int_array_make(5);
    // a's memory is dropped/freed
    int_array_drop(a);

}
            </code></pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers="11-12|15-16|1-1000">
IntArray int_array_make(size_t length) {
  return (IntArray) {.length = length,
                     .values = calloc(sizeof(int), length)};
}

void int_array_drop(IntArray a) { free(a.values); }

int main(void) {
    // a owns the memory
    IntArray a = int_array_make(5);
    // oh no, now both a and b own the memory
    IntArray b = a;
    // a's memory is dropped/freed
    int_array_drop(a);
    // use after free because there were two "owners"
    printf("%d\n", b.values[1]); // Seg Fault
}
            </code></pre>
            <p class="fragment">
            Nao correu muito bem, vamos ver como √© que Rust impede que isto aconte√ßa.
            </p>
          </section>
          <section data-auto-animate>
            Vamos partir do mesmo ponto. Um array est√°tico.
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers>
                type IntArray = Box<[i32]>;
              </code>
            </pre>
            Em Rust o array √© um tipo predefinido, o que esta linha faz √©
            apenas definir um "type alias" para tentar aproximar ao maximo possivel
            ao codigo C.
            <br>
            Este tipo √© exatamente equivalente ao tipo em C, por de traz
            desta sintaxe est√° apenas um pointer e um comprimento.
          </section>
          <section data-auto-animate>
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="4-5|6-7|1-1000">
                type IntArray = Box<[i32]>;

                fn main() {
                  // a owns the memory
                  let a: IntArray = vec![0; 5].into_boxed_slice();
                  // a's memory is dropped
                  drop(a);
                }
              </code>
            </pre>
            <p class="fragment"> Agora vamos tentar criar o mesmo erro. </p>
          </section>
          <section data-auto-animate>
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="6-7|10-11">
                type IntArray = Box<[i32]>;

                fn main() {
                  // a owns the memory
                  let a: IntArray = vec![0; 5].into_boxed_slice();
                  // Move a to b
                  let b = a;
                  // a's memory is dropped
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
            </pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <div class="r-stack">
              <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers>
                type IntArray = Box<[i32]>;

                fn main() {
                  // a owns the memory
                  let a: IntArray = vec![0; 5].into_boxed_slice();
                  // Move a to b
                  let b = a;
                  // a's memory is dropped
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
              </pre>
              <img src="img/use_after_move.png" />
            </div>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers>
                type IntArray = Box<[i32]>;

                fn main() {
                  // a owns the memory
                  let a: IntArray = vec![0; 5].into_boxed_slice();
                  // Move a to b
                  let b = a;
                  // a doesn't own the memory anymore and is 'uninitialized'
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
            </pre>
            <img src="img/use_after_move.png" />
          </section>
          <section>
            <div class="fragment" style="text-align: left">
              <h4> Double free </h4>
              Assim, usando os invariantes:
              <ul>
                <li> Para cada bloco de mem√≥ria, existe apenas um dono*. </li>
                <li> Apenas o dono de um bloco mem√≥ria pode libertar o mesmo. </li>
              </ul>
              Podemos concluir ter a certeza que nunca existir√° um "double free".
            </div>
            <br>
            <div class="fragment" style="text-align: left">
              <h4> Use after free </h4>
              Sempre que a <em>ownership</em> de um bloco de mem√≥ria √© passada
              de uma vari√°vel para outra, a antiga fica num estado inutiliz√°vel,
              e o compilador garante que n√£o ser√° mais acedida. Isto em conjunto
              com a anterior garante que n√£o podem usar "use after free" bugs.
            </div>
          </section>
        </section>
        <section>
          <h1>Borrowing</h1>
          <section>
            <p class="fragment">
            Mas <em>ownership</em> sozinha n√£o chega para lidar com estes bugs,
            √© demasiado restritivo, e se precisar mos que v√°rias partes do
            c√≥digo tenham acesso ao mesmo objecto? A √≥bvia resposta √© usar um
            pointer que √© partilhado, mas isto tamb√©m pode criar mais
            <em>memory safety bugs</em>.
            </p>
            <p class="fragment">
            Assumindo que nunca usamos este pointer para libertar mem√≥ria,
            podemos ter na mesma um "use after free" ou como √© mais
            comum chamar neste caso, um dangling pointer.
            </p>
            <p class="fragment">
            Para resolver isto podemos pensar no conceito de borrowing.
            Efectivamente o que o compilador previne √© que enquanto um objecto
            est√° emprestado, o dono n√£o o pode alterar, incluindo libertar a
            mem√≥ria utilizada por este.
            </p>
          </section>
          <section>
            <h4>H√° dois tipos de borrows em Rust:</h4>
            <ul>
              <li class="fragment" data-fragment-index="1"><b>shared</b> (ou <b>immutable</b>):
                <span class="fragment" data-fragment-index="3">
                  Podem existir qualquer n√∫mero de shared borrows, para um
                  determinado objecto, mas n√£o podem haver exclusive borrows
                  simult√¢neos.
                </span>
              </li>
              <li class="fragment" data-fragment-index="2"><b>exclusive</b> (ou <b>mutable</b>):
                <span class="fragment" data-fragment-index="4">
                  Em qualquer ponto do c√≥digo se existe um exclusive
                  borrow, n√£o pode existir mais nenhum borrow, shared ou
                  exclusive.
                </span>
              </li>
            </ul>
            <p class="fragment">
            Isto √© tudo um bocado abstracto, por isso vamos ver mais um exemplo
            da utilidade disto, come√ßando mais uma vez com C
            </p>
          </section>
          <section data-auto-animate>
            Vamos fazer um array din√¢mico simples.

            <pre class="lang-c" data-id="code-animation"><code data-trim>
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;
            </code></pre>
            <ul>
              <li> <b>values</b>: Tem um pointer para os valores que o array guarda.</li>
              <li> <b>used</b>: √â quantos elementos tem. </li>
              <li> <b>capacity</b>: Quanto espa√ßo tem o array de values </li>
            </ul>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers="8-9|10-11|12-13|15-16|7-17|1-1000">
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;

void int_vec_push(IntVec* self, int value) {
  // Caso o vector esteja cheio
  if(self->capacity == self->used) {
    // Duplicar a capacidade do vector
    self->capacity = self->capacity == 0 ? 1 : self->capacity * 2;
    // Realocar o array, usando agora o dobro da capacidade
    self->values = realloc(self->values, sizeof(int) * self->capacity);
  }
  // Adicionar ao vector
  self->values[self->used++] = value;
}
            </code></pre>
            <p class="fragment">
            A linha mais importante deste c√≥digo e a 13. Nesta linha podemos ver
            que o pointer <code>self->values</code> muda!
            </p>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers="6|6-9|6-12|6-15|6-18|1-1000">
typedef struct { int* values; size_t capacity, used; } IntVec;

void int_vec_push(IntVec* self, int value);

int main(void) {
  IntVec v = int_vec_make();

  // Fazemos push de um valor
  int_vec_push(&v, 1); // isto realoca porque capacity(0) == used(0)

  // Criamos um pointer para o primeiro valor do vector
  int* first_value = &v.values[0];

  // Fazemos push de mais um valor
  int_vec_push(&v, 2); // capacity(1) == used(1) ent√£o realocamos mais uma vez

  // Tentamos alterar o primeiro valor do vector
  *first_value = 42; // Seg Fault
}
            </code></pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers>
typedef struct { int* values; size_t capacity, used; } IntVec;

void int_vec_push(IntVec* self, int value);

int main(void) {
  IntVec v = int_vec_make();
  // Fazemos push de um valor
  int_vec_push(&v, 1); // isto realoca porque capacity(0) == used(0)
  // Criamos um pointer para o primeiro valor do vector
  int* first_value = &v.values[0];
  // Fazemos push de mais um valor
  int_vec_push(&v, 2); // capacity(1) == used(1) ent√£o realocamos mais uma vez
  // Tentamos alterar o primeiro valor do vector
  *first_value = 42; // Seg Fault
}
            </code></pre>
            Como podemos ver o <code>first_value</code> passa a ser um dangling
            pointer depois da linha 12, e quando tentamos utiliz√°-lo mais a frente
            o nosso programa crasha.
          </section>
          <section data-auto-animate>
            Agora com Rust.
            <pre class="lang-rust" data-id="code-animation">
            <code data-trim data-noescape data-line-numbers>
            type IntVec = Vec&lt;i32&gt;;
            </code></pre>
            Em Rust o array din√¢mico j√° esta implementado, isto mais uma vez √©
            apenas um type alias para aproximar mais a C. Neste caso
            <code>Vec&lt;i32&gt;</code> e o vector de inteiros de 32 bits, que
            funciona de forma muito similar ao que implementamos em C.
          </section>
          <section data-auto-animate>
            <pre class="lang-rust" data-id="code-animation">
            <code data-trim data-line-numbers="4|4-7|4-10|4-13|4-16|1-1000">
            type IntVec = Vec&lt;i32&gt;;

            fn main() {
              let mut v = IntVec::new();

              // Fazemos push de um valor
              v.push(1);

              // Criamos um pointer para o primeiro valor do vector
              let first_value = &mut v[0];

              // Fazemos push de mais um valor
              v.push(2);

              // Tentamos alterar o primeiro valor do vector
              *first_value = 42;
            }
            </code></pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <div class="r-stack">
              <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers>
              type IntVec = Vec&lt;i32&gt;;

              fn main() {
                let mut v = IntVec::new();

                // Fazemos push de um valor
                v.push(1);

                // Criamos um pointer para o primeiro valor do vector
                let first_value = &mut v[0];

                // Fazemos push de mais um valor
                v.push(2);

                // Tentamos alterar o primeiro valor do vector
                *first_value = 42;
              }
              </code>
              </pre>
              <img src="img/multiple_mutable_borrows.png" />
            </div>
          </section>
          <section data-auto-animate>
            <div class="r-stack">
              <div style="width:100%">
                <pre class="lang-rust" data-id="code-animation">
                  <code data-trim data-line-numbers>
                  type IntVec = Vec&lt;i32&gt;;

                  fn main() {
                    let mut v = IntVec::new();
                    // Fazemos push de um valor
                    v.push(1);
                    // Criamos um pointer para o primeiro valor do vector
                    let first_value = &mut v[0];
                    // Fazemos push de mais um valor
                    v.push(2);
                    // Tentamos alterar o primeiro valor do vector
                    *first_value = 42;
                  }
                  </code>
                </pre>
                <img src="img/multiple_mutable_borrows_short.png" />
              </div>
              <img src="img/vec_push_signature.png"/>
            </div>
          </section>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
              hash: true,
              // Learn about plugins: https://revealjs.com/plugins/
              plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
            });
    </script>
  </body>
</html>
