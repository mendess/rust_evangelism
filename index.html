<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Rust Evangelism</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black2.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/gruvbox-dark.css"
      id="highlight-theme">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1 class="title">Rust Evangelism</h1>
          <p class="subtitle">ü¶Ä</p>
          <p class="author">Pedro Mendes</p>
        </section>
        <section data-markdown>
          <textarea data-template>
            # _disclaimer_

            Esta talk n√£o √© um tutorial de Rust!

            √â apenas uma demonstra√ß√£o das features que acho mais
            interessantes da linguagem.
          </textarea>
        </section>
        <section>
          <h1>O que √© Rust?</h1>
          <section>
            Rust √© uma <em>systems programming language</em>, ou seja, permite
            ter um controlo de baixo n√≠vel do hardware e recursos da m√°quina.
            <br>
            As duas linguagens mais conhecidas neste campo s√£o
            <img
              style='vertical-align:middle;'
              src="img/c.png"
              alt="C"
              height="40em"/>
            e
            <img
              style='vertical-align:middle;'
              src="img/cpp.png"
              alt="C++"
              height="40em"/>.
          </section>
          <section>
            <h3>Porqu√™ fazer uma linguagem nova?</h3>

            <img
              style='vertical-align:middle;'
              src="img/c.png"
              alt="C"
              height="40em"/>,
              <img
                style='vertical-align:middle;'
                src="img/cpp.png"
                alt="C++"
                height="40em"/>
              s√£o linguagens que d√£o muito poder e controlo
              a quem as usa,
              deixam controlar todos os detalhes. Mas...
              <div class="fragment">
                <blockquote>
                  With great power, comes great responsibility
                </blockquote>
                <p style="text-align: right"> ‚Äì Spider Man probably</p>
              </div>
          </section>
          <section>
            Qual √© o principal dificuldade de trabalhar com estas linguagens?
            <span class="fragment">Gest√£o de mem√≥ria.</span>

            <pre class="fragment"> Segmentation fault (core dumped) </pre>

            <aside class="notes">
              E se houvesse uma linguagem lowlevel em que n√£o e poss√≠vel*
              compilar sequer
              c√≥digo que pode dar segmentation fault?
            </aside>
          </section>
        </section>
        <section>
          <h1>Ownership</h1>
          <section>
            <em>Ownership</em> √© um dos <em>mental models</em> que podemos
            utilizar para conseguir evitar um conjunto de bugs como "double
            free" ou "use after free".

            <div class="fragment">
              Podemos ver <em>ownership</em> como uma forma de responder √†
              pergunta:
              "Quem √© respons√°vel por libertar esta mem√≥ria?"
            </div>
          </section>
          <section data-auto-animate>
            Come√ßando por fazer um array din√¢mico simples em
            <img
              style='vertical-align:middle;'
              src="img/c.png"
              alt="C"
              height="40em"/>

            <pre class="lang-c" data-id="code-animation"><code data-trim>
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;
            </code></pre>
            <ul>
              <li>
                <b>values</b>:
                Tem um pointer para os valores que o array guarda.
              </li>
              <li> <b>used</b>: √â quantos elementos tem. </li>
              <li> <b>capacity</b>: Quanto espa√ßo tem o array de values </li>
            </ul>
            <aside class="notes">
              Para vermos este conceito em a√ß√£o vamos escrever um pouco de C
              onde estas garantias n√£o existem.
            </aside>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers="7-10|7-12|7-16|7-18|1-1000">
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;

IntVec int_vec_make(size_t initial_cap) {
  return (IntVec) {.capacity = initial_cap, .used = 0,
                   .values = malloc(sizeof(int) * initial_cap)};
}

void int_vec_drop(IntVec a) { free(a.values); }

int main(void) {
    // a owns the memory
    IntVec a = int_vec_make(5);
    // a's memory is dropped/freed
    int_array_drop(a);
}
            </code></pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers="11-12|11-14|11-16">
IntVec int_vec_make(size_t initial_cap) {
  return (IntVec) {.capacity = initial_cap, .used = 0,
                     .values = malloc(sizeof(int) * initial_cap)};
}

void int_vec_drop(IntVec a) { free(a.values); }

int main(void) {
    // a owns the memory
    IntVec a = int_vec_make(5);
    // oh no, now both a and b own the memory
    IntVec b = a;
    // a's memory is dropped/freed
    int_vec_drop(a);
    // use after free because there were two "owners"
    printf("%d\n", b.values[1]);
}
            </code></pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers="1-17">
IntVec int_vec_make(size_t initial_cap) {
  return (IntVec) {.capacity = initial_cap, .used = 0,
                     .values = malloc(sizeof(int) * initial_cap)};
}

void int_vec_drop(IntVec a) { free(a.values); }

int main(void) {
    // a owns the memory
    IntVec a = int_vec_make(5);
    // oh no, now both a and b own the memory
    IntVec b = a;
    // a's memory is dropped/freed
    int_vec_drop(a);
    // use after free because there were two "owners"
    printf("%d\n", b.values[1]); // SEGMENTATION FAULT
}
            </code></pre>
            <aside class="notes">
              Nao correu muito bem, vamos ver como √© que Rust impede que isto
              aconte√ßa.
            </aside>
          </section>
          <section data-auto-animate>
            Vamos partir do mesmo ponto.
            <br>
            Um array din√¢mico, em Rust chama-se vector e j√° est√° implementado.
            <pre class="lang-rust" data-id="code-animation">
              <code style="text-align: center; font-size: 28px">
Vec&lt;i32&gt;</code>
            </pre>
            Este tipo √© equivalente ao IntVec de
            <img
            style='vertical-align:middle;'
            src="img/c.png"
            alt="C"
            height="40em"/>

            <aside class="notes">
            √â um pointer, capacity, e used.
            </aside>
            <br>
          </section>
          <section data-auto-animate>
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="2-3|4-5|1-1000">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // a's memory is dropped
                  drop(a);
                }
              </code>
            </pre>
            <aside class="notes">
              Explicar syntax
            </aside>
          </section>
          <section data-auto-animate>
            Agora vamos tentar criar o mesmo erro.
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="4-6|4-9">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // Move a --to--&gt; b
                  let b = a;
                  // a's memory is dropped
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
            </pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <div class="r-stack">
              <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="1-10">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // Move a --to--&gt; b
                  let b = a;
                  // a's memory is dropped
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
              </pre>
              <img src="img/use_after_move.png" />
            </div>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="1-10">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // Move a --to--&gt; b
                  let b = a;
                  // a doesn't own the memory anymore and is 'uninitialized'
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
            </pre>
            <img src="img/use_after_move.png" />
          </section>
          <section>
            <div style="text-align: left">
              <h4 class="fragment" data-fragment-index="1"> Como √© que Rust previne estes bugs ?  </h4>
              <h4 class="fragment" data-fragment-index="2"> Double free </h4>
              <div class="fragment" data-fragment-index="3">
                <ul>
                  <li> Para cada bloco de mem√≥ria, existe apenas um dono. </li>
                  <li>
                    Apenas o dono de um bloco mem√≥ria pode libertar o mesmo.
                  </li>
                </ul>
              </div>
            </div>
            <br>
            <div style="text-align: left">
              <h4 class="fragment" data-fragment-index="4"> Use after free </h4>
              <div class="fragment" data-fragment-index="5">
                Sempre que a <em>ownership</em> de um bloco de mem√≥ria √© passada
                de uma vari√°vel para outra, a antiga fica num estado
                inutiliz√°vel, e o compilador garante que n√£o ser√° mais acedida.
              </div>
            </div>
          </section>
        </section>
        <section>
          <h1>Lifetimes</h1>
          <section>
            <p class="fragment">
            Isto √© um pouco restritivo
            <br>
            E se quisermos partilhar um objecto por varias
            partes do codigo?
            </p>
            <p class="fragment">
            Pointers?
            </p>
            <p class="fragment">
            Mas assim introduzimos "use after free" bugs outra vez...
            </p>
            <aside class="notes">
              <p>
              Mas <em>ownership</em> sozinha n√£o chega para criar uma linguagem
              us√°vel. √Ås vezes √© necess√°rio partilhar um objecto por varias
              partes do nosso c√≥digo.
              </p>
              <p>
              Mas se o pointer existir mais tempo que objecto para que aponta,
              temos um "use after free", aka, um dangling pointer.
              </p>
            </aside>
          </section>
          <section>
            <b>Lifetime:</b> Regi√£o do programa em que um dado objecto existe.
            <br>
            <br>
            <br>
            Portanto isto √© """simples""" um pointer/referencia nunca pode
            existir mais "tempo" do que o objecto para que aponta.
          </section>
          <section>
            Podemos pensar que as <tt>{}</tt> delimitam o <em>lifetime</em> de
            um objecto
            <div class="r-stack">
              <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers>
              <script type="text/template">
                int foo() {
                  int* i; // lifetime of i starts here
                  {
                    int x = 42; // lifetime of x starts here
                    i = &x;
                  } // lifetime of x ends here
                  return *i;
                } // lifetime of i ends here
              </script>
              </code>
              </pre>
              <pre class="lang-c fragment" data-id="code-animation">
              <code data-trim data-line-numbers>
              <script type="text/template">
                int foo() {
                  int* i;       // 'i
                  {             // 'i
                    int x = 42; // 'i 'x
                    i = &x;     // 'i 'x
                  }             // 'i
                  return *i;    // 'i
                }
              </script>
              </code>
              </pre>
              <pre class="lang-c fragment" data-id="code-animation">
              <code data-trim data-line-numbers>
              <script type="text/template">
                  int foo() {
                    int* i;
                    {
                      int x = 42;
                      i = &x;
                    }
                    return *i; // Undefined behaviour
                  }
              </script>
              </code>
              </pre>
            </div>
          </section>
          <section>
            <h3>Undefined Behaviour</h3>
            <p>
            Algumas "constru√ß√µes" s√£o consideradas UB pelo standard de
            C e o compilador tem a liberdade fazer o que quiser com o programa
            assim que encontra UB.
            </p>

            <div class="fragment">
              <p>
              Por exemplo, em <tt>gcc version 10.2.0</tt> compilar o programa
              anterior, com <tt>-O2</tt>, resulta no seguinte assembly para a
              fun√ß√£o <tt>foo</tt>.
              </p>
              <pre class="lang-asm">
            <code data-trim>
            xor %eax,%eax
            retq
              </code></pre>
            </div>
            <aside class="notes">
              Mas isto ainda fica pior! Vamos ver ainda outro exemplo.
            </aside>
          </section>
          <section data-auto-animate>
            <pre class="lang-c">
              <code data-trim data-line-numbers>
              <script type="text/template">
                int* foo() {
                  int* a[] = {1,2,3}; // lifetime of `a` starts
                  return a;
                } // lifetime of `a` ends
                int main() {
                  int* a = foo();
                  printf("%d,%d,%d\n", a[0], a[1], a[2]);
                }
              </script>
              </code>
            </pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c">
              <code data-trim data-line-numbers>
              <script type="text/template">
                int* foo() {
                  int* a[] = {1,2,3}; // lifetime of `a` starts
                  return a;
                } // lifetime of `a` starts
                int main() {
                  int* a = foo();
                  printf("%d,%d,%d\n", a[0], a[1], a[2]);
                }
              </script>
              </code>
            </pre>
            <pre class="lang-asm" data-id="code-animation">
              <code data-trim>
              &lt;foo&gt;:
                xor %eax,%eax
                retq
              </code>
            </pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c">
              <code data-trim data-line-numbers>
              <script type="text/template">
                int* foo() {
                  int* a[] = {1,2,3}; // lifetime of `a` starts
                  return a;
                } // lifetime of `a` ends
                int main() {
                  int* a = foo();
                  printf("%d,%d,%d\n", a[0], a[1], a[2]);
                }
              </script>
              </code>
            </pre>
            <pre class="lang-asm" data-id="code-animation">
              <code data-trim>
              &lt;foo&gt;:
                xor %eax,%eax
                retq
              &lt;main&gt;:
                mov 0x0,%eax
                ud2
              </code>
            </pre>
            <a class="fragment"
              href="https://www.felixcloutier.com/x86/ud">? ud2 ?</a>
          <aside class="notes">
            ud2 e uma instru√ß√£o de assembly invalida, de certa forma e um
            Segmentation Fault hardcoded no programa. Tal como disse antes o
            compilador pode fazer o que bem entende quando encontra UB

            Mais uma vez, isto e um bug que Rust simplesmente n√£o permite,
            fazendo uso de lifetimes.
          </aside>
          </section>
          <section data-auto-animate>
            <pre class="lang-rust">
              <code data-trim data-line-numbers>
              <script type="text/template">
                fn main() {
                  let i;
                  {
                    let x = 42;
                    i = &x;
                  }
                  println!("{}", *i);
                }
              </script>
              </code>
            </pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-rust">
              <code data-trim data-line-numbers>
              <script type="text/template">
                fn main() {
                  let i;
                  {
                    let x = 42;
                    i = &x;
                  }
                  println!("{}", *i);
                }
              </script>
              </code>
            </pre>
            <img src="img/lifetimes0.png"/>
          </section>
        </section>
        <section>
          <h1>Borrowing</h1>
          <section>
          </section>
          <section>
            <h4>H√° dois tipos de borrows em Rust:</h4>
            <ul>
              <li
                class="fragment"
                data-fragment-index="1">
                <b>shared</b> (ou <b>immutable</b>):
                <div class="fragment" data-fragment-index="3">
                  Podem existir qualquer n√∫mero de shared borrows para um
                  determinado objecto, e 0 exclusive.
                  </span>
              </li>
              <li
                class="fragment"
                data-fragment-index="2">
                <b>exclusive</b> (ou <b>mutable</b>):
                <div class="fragment" data-fragment-index="4">
                  Em qualquer ponto do c√≥digo s√≥ pode existir um exclusive
                  borrow activo.
                  </span>
              </li>
            </ul>
            <aside class="notes">
              Mas isto √© muito abstrato, vamos ver um exemplo na nossa trusty C
              language.
            </aside>
          </section>
          <section data-auto-animate>
            Vamos continuar a utilizar o array din√¢mico da sec√ß√£o anterior.

            <pre class="lang-c" data-id="code-animation"><code data-trim>
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;
            </code></pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers="1-1000|7-9|7-11|7-13|7-16|1-1000">
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;

void int_vec_push(IntVec* self, int value) {
  // Caso o vector esteja cheio
  if(self->capacity == self->used) {
    // Duplicar a capacidade do vector
    self->capacity *= 2;
    // Realocar o array, usando agora o dobro da capacidade
    self->values = realloc(self->values, sizeof(int) * self->capacity);
  }
  // Adicionar ao vector
  self->values[self->used++] = value;
}
            </code></pre>
            <p class="fragment">
            A linha mais importante deste c√≥digo e a 13. Nesta linha podemos ver
            que o pointer <code>self->values</code> muda!
            </p>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers="6|6-9|6-12|6-15|6-18|1-19">
typedef struct { int* values; size_t capacity, used; } IntVec;

void int_vec_push(IntVec* self, int value);

int main(void) {
  IntVec v = int_vec_make(0);

  // Fazemos push de um valor
  int_vec_push(&v, 1); // isto realoca porque capacity(0) == used(0)

  // Criamos um pointer para o primeiro valor do vector
  int* first_value_ptr = &v.values[0];

  // Fazemos push de mais um valor
  int_vec_push(&v, 2); // capacity(1) == used(1) ent√£o realocamos

  // Tentamos alterar o primeiro valor do vector
  *first_value_ptr = 42;
}
            </code></pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers="1-19">
typedef struct { int* values; size_t capacity, used; } IntVec;

void int_vec_push(IntVec* self, int value);

int main(void) {
  IntVec v = int_vec_make(0);

  // Fazemos push de um valor
  int_vec_push(&v, 1); // isto realoca porque capacity(0) == used(0)

  // Criamos um pointer para o primeiro valor do vector
  int* first_value_ptr = &v.values[0];

  // Fazemos push de mais um valor
  int_vec_push(&v, 2); // capacity(1) == used(1) ent√£o realocamos

  // Tentamos alterar o primeiro valor do vector
  *first_value_ptr = 42; // SEGMENTATION FAULT
}
            </code></pre>
            <aside class="notes">
            Como podemos ver o <code>first_value_ptr</code> passa a ser um
            dangling pointer depois da linha 12, e quando tentamos utiliz√°-lo
            mais a frente o nosso programa crasha.
            </aside>
          </section>
          <section data-auto-animate>
            <pre class="lang-rust" data-id="code-animation">
            <code data-trim data-line-numbers="2|2-5|2-8|2-11|2-14|1-15">
            fn main() {
              let mut v = Vec::new();

              // Fazemos push de um valor
              v.push(1);

              // Criamos um pointer para o primeiro valor do vector
              let first_value_ptr = &mut v[0];

              // Fazemos push de mais um valor
              v.push(2);

              // Tentamos alterar o primeiro valor do vector
              *first_value_ptr = 42;
            }
            </code></pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <div class="r-stack">
              <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="1-15">
              fn main() {
                let mut v = Vec::new();

                // Fazemos push de um valor
                v.push(1);

                // Criamos um pointer para o primeiro valor do vector
                let first_value_ptr = &mut v[0];

                // Fazemos push de mais um valor
                v.push(2);

                // Tentamos alterar o primeiro valor do vector
                *first_value_ptr = 42;
              }
              </code>
              </pre>
              <img src="img/multiple_mutable_borrows.png" />
            </div>
          </section>
          <section data-auto-animate>
            <div class="r-stack">
              <div style="width:100%">
                <pre class="lang-rust" data-id="code-animation">
                  <code data-trim data-line-numbers="1-11">
                  fn main() {
                    let mut v = Vec::new();
                    // Fazemos push de um valor
                    v.push(1);
                    // Criamos um pointer para o primeiro valor do vector
                    let first_value_ptr = &mut v[0];
                    // Fazemos push de mais um valor
                    v.push(2);
                    // Tentamos alterar o primeiro valor do vector
                    *first_value_ptr = 42;
                  }
                  </code>
                </pre>
                <img src="img/multiple_mutable_borrows_short.png" />
              </div>
              <img class="fragment" src="img/vec_push_signature.png"/>
            </div>
            <aside class="notes">
              Memory corruption
            </aside>
          </section>
          <section data-auto-animate>
            <div class="r-stack">
              <div style="width:100%">
                <pre class="lang-rust" data-id="code-animation">
                  <code data-trim data-line-numbers="1-11">
                  fn main() {
                    let mut v = Vec::new();
                    // Fazemos push de um valor
                    Vec::push(&mut v, 1); // equivalente a v.push(1);
                    // Criamos um pointer para o primeiro valor do vector
                    let first_value_ptr = &mut v[0];
                    // Fazemos push de mais um valor
                    Vec::push(&mut v, 2); // equivalente a v.push(2);
                    // Tentamos alterar o primeiro valor do vector
                    *first_value_ptr = 42;
                  }
                  </code>
                </pre>
                <img src="img/multiple_mutable_borrows_short.png" />
              </div>
              <img src="img/vec_push_signature.png"/>
            </div>
            <aside class="notes">
              Memory corruption
            </aside>
          </section>
        </section>
        </section>
                </div>
                </div>

                <script src="dist/reveal.js"></script>
                <script src="plugin/notes/notes.js"></script>
                <script src="plugin/markdown/markdown.js"></script>
                <script src="plugin/highlight/highlight.js"></script>
                <script>
                  // More info about initialization & config:
                  // - https://revealjs.com/initialization/
                  // - https://revealjs.com/config/
                  Reveal.initialize({
                                      hash: true,
                                      // Learn about plugins: https://revealjs.com/plugins/
                                      plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
                                    });
                </script>
  </body>
</html>
