<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Rust Evangelism</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black2.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/gruvbox-dark.css"
      id="highlight-theme">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1 class="title">Rust Evangelism</h1>
          <p class="subtitle">ü¶Ä</p>
          <p class="author">Pedro Mendes</p>
        </section>
        <section data-markdown>
          <textarea data-template>
            # _disclaimer_

            Esta talk n√£o √© um tutorial de Rust!

            Esta talk √© eu a falar das partes que eu mais gosto da linguagem
            para mostrar o que √© Rust and _what is the hype all about_.

          </textarea>
        </section>
        <section>
          <h1>O que √© Rust?</h1>
          <section data-markdown>
            <textarea data-template>
              Rust √© uma _systems programming language_, isto quer dizer que √©
              uma linguagem que permite ter um controlo de baixo n√≠vel do
              hardware e recursos da m√°quina.

              As duas linguagens mais conhecidas neste campo s√£o C e C++.
            </textarea>
          </section>
          <section>
            <h2>Porqu√™ fazer uma linguagem nova</h2>

            C, C++ s√£o linguagens que d√£o muito poder e controlo a quem as usa,
            deixam controlar todos os detalhes. Mas...
            <div class="fragment">
              <blockquote>
                With great power, comes great responsibility
              </blockquote>
              <p style="text-align: right"> ‚Äì Spider Man probably</p>
            </div>
          </section>
        </section>
        <section>
          <h1>Ownership</h1>
          <section>
            Qual √© o principal dificuldade de trabalhar com estas linguagens?
            <span class="fragment">Gest√£o de mem√≥ria.</span>

            <div class="fragment">
              Quem √© aqui adora esta mensagem de erro?
              <pre> Segmentation fault (core dumped) </pre>
            </div>
            <div class="fragment">
              E se houvesse uma linguagem em que n√£o e poss√≠vel* compilar sequer
              c√≥digo que pode dar segmentation fault?
            </div>

            <div class="fragment"><em>mas como?</em></div>

          </section>
          <section>
            <em>Ownership</em> √© um dos <em>mental models</em> que podemos
            utilizar para conseguir evitar um conjunto de bugs como "double
            free" ou "use after free".

            <div class="fragment">
              Podemos ver <em>ownership</em> como uma forma de responder √†
              pergunta:
              "Quem √© respons√°vel por libertar esta mem√≥ria?"
            </div>
          </section>
          <section data-auto-animate>
            Para vermos este conceito em a√ß√£o vamos escrever um pouco de C
            onde estas garantias n√£o existem.
            <br>
            Come√ßando por fazer um array din√¢mico simples.

            <pre class="lang-c" data-id="code-animation"><code data-trim>
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;
            </code></pre>
            <ul>
              <li>
                <b>values</b>:
                Tem um pointer para os valores que o array guarda.
              </li>
              <li> <b>used</b>: √â quantos elementos tem. </li>
              <li> <b>capacity</b>: Quanto espa√ßo tem o array de values </li>
            </ul>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers="7-10|7-12|7-16|7-18|1-1000">
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;

IntVec int_vec_make(size_t initial_cap) {
  return (IntVec) {.capacity = initial_cap, .used = 0,
                   .values = malloc(sizeof(int) * initial_cap)};
}

void int_vec_drop(IntVec a) { free(a.values); }

int main(void) {
    // a owns the memory
    IntVec a = int_vec_make(5);
    // a's memory is dropped/freed
    int_array_drop(a);
}
            </code></pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
              <code data-trim data-line-numbers="11-12|11-14|11-16|1-1000">
IntVec int_vec_make(size_t initial_cap) {
  return (IntVec) {.capacity = initial_cap, .used = 0,
                     .values = malloc(sizeof(int) * initial_cap)};
}

void int_vec_drop(IntVec a) { free(a.values); }

int main(void) {
    // a owns the memory
    IntVec a = int_vec_make(5);
    // oh no, now both a and b own the memory
    IntVec b = a;
    // a's memory is dropped/freed
    int_vec_drop(a);
    // use after free because there were two "owners"
    printf("%d\n", b.values[1]); // Seg Fault
}
            </code></pre>
            <p class="fragment">
            Nao correu muito bem, vamos ver como √© que Rust impede que isto
            aconte√ßa.
            </p>
          </section>
          <section data-auto-animate>
            Vamos partir do mesmo ponto. Um array din√¢mico, em Rust chama-se
            vector e j√° est√° implementado.
            <pre class="lang-rust" data-id="code-animation">
              <code style="text-align: center; font-size: 28px">
Vec&lt;i32&gt;</code>
            </pre>
            Este tipo √© equivalente ao tipo em C, √© apenas um
            <tt>pointer</tt>, <tt>capacity</tt>, e <tt>used</tt>.
            <br>
          </section>
          <section data-auto-animate>
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="2-3|4-5|1-1000">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // a's memory is dropped
                  drop(a);
                }
              </code>
            </pre>
            <p class="fragment"> Agora vamos tentar criar o mesmo erro. </p>
          </section>
          <section data-auto-animate>
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="4-6|4-9">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // Move a --to--&gt; b
                  let b = a;
                  // a's memory is dropped
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
            </pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <div class="r-stack">
              <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="1-10">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // Move a --to--&gt; b
                  let b = a;
                  // a's memory is dropped
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
              </pre>
              <img src="img/use_after_move.png" />
            </div>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="1-10">
                fn main() {
                  // a owns the memory
                  let a: Vec&lt;i32&gt; = Vec::with_capacity(5);
                  // Move a --to--&gt; b
                  let b = a;
                  // a doesn't own the memory anymore and is 'uninitialized'
                  drop(a);
                  // try to use b
                  println!("{}", b[1]);
                }
              </code>
            </pre>
            <img src="img/use_after_move.png" />
          </section>
          <section>
            <div style="text-align: left">
              <h4 class="fragment" data-fragment-index="1"> Double free </h4>
              <div class="fragment" data-fragment-index="3">
                Assim, usando os invariantes:
                <ul>
                  <li> Para cada bloco de mem√≥ria, existe apenas um dono*. </li>
                  <li>
                    Apenas o dono de um bloco mem√≥ria pode libertar o mesmo.
                  </li>
                </ul>
                Podemos concluir ter a certeza que nunca existir√° um "double
                free".
              </div>
            </div>
            <br>
            <div style="text-align: left">
              <h4 class="fragment" data-fragment-index="2"> Use after free </h4>
              <div class="fragment" data-fragment-index="4">
                Sempre que a <em>ownership</em> de um bloco de mem√≥ria √© passada
                de uma vari√°vel para outra, a antiga fica num estado
                inutiliz√°vel, e o compilador garante que n√£o ser√° mais acedida.
                Isto em conjunto com a anterior garante que n√£o podem usar "use
                after free" bugs.
              </div>
            </div>
          </section>
        </section>
        <section>
          <h1>Borrowing</h1>
          <section>
            <p class="fragment">
            Mas <em>ownership</em> sozinha n√£o chega para criar uma linguagem
            us√°vel. √Ås vezes √© necess√°rio partilhar um objecto por varias partes
            do nosso c√≥digo.
            </p>
            <p class="fragment">
            Mas se o pointer existir mais tempo que objecto para que aponta,
            temos um "use after free", aka, um dangling pointer.
            </p>
          </section>
          <section>
            <h4>H√° dois tipos de borrows em Rust:</h4>
            <ul>
              <li
                class="fragment"
                data-fragment-index="1">
                <b>shared</b> (ou <b>immutable</b>):
                <div class="fragment" data-fragment-index="3">
                  Podem existir qualquer n√∫mero de shared borrows para um
                  determinado objecto, e 0 exclusive.
                </span>
              </li>
              <li
                class="fragment"
                data-fragment-index="2">
                <b>exclusive</b> (ou <b>mutable</b>):
                <div class="fragment" data-fragment-index="4">
                  Em qualquer ponto do c√≥digo s√≥ pode existir um exclusive
                  borrow activo.
                </span>
              </li>
            </ul>
          </section>
          <section data-auto-animate>
            Vamos continuar a utilizar o array din√¢mico da sec√ß√£o anterior.

            <pre class="lang-c" data-id="code-animation"><code data-trim>
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;
            </code></pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers="1-1000|7-9|7-11|7-13|7-16|1-1000">
typedef struct {
    int* values;
    size_t capacity;
    size_t used;
} IntVec;

void int_vec_push(IntVec* self, int value) {
  // Caso o vector esteja cheio
  if(self->capacity == self->used) {
    // Duplicar a capacidade do vector
    self->capacity *= 2;
    // Realocar o array, usando agora o dobro da capacidade
    self->values = realloc(self->values, sizeof(int) * self->capacity);
  }
  // Adicionar ao vector
  self->values[self->used++] = value;
}
            </code></pre>
            <p class="fragment">
            A linha mais importante deste c√≥digo e a 13. Nesta linha podemos ver
            que o pointer <code>self->values</code> muda!
            </p>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers="6|6-9|6-12|6-15|6-18|1-1000">
typedef struct { int* values; size_t capacity, used; } IntVec;

void int_vec_push(IntVec* self, int value);

int main(void) {
  IntVec v = int_vec_make(0);

  // Fazemos push de um valor
  int_vec_push(&v, 1); // isto realoca porque capacity(0) == used(0)

  // Criamos um pointer para o primeiro valor do vector
  int* first_value_ptr = &v.values[0];

  // Fazemos push de mais um valor
  int_vec_push(&v, 2); // capacity(1) == used(1) ent√£o realocamos

  // Tentamos alterar o primeiro valor do vector
  *first_value_ptr = 42; // Seg Fault
}
            </code></pre>
          </section>
          <section data-auto-animate>
            <pre class="lang-c" data-id="code-animation">
            <code data-trim data-line-numbers>
typedef struct { int* values; size_t capacity, used; } IntVec;

void int_vec_push(IntVec* self, int value);

int main(void) {
  IntVec v = int_vec_make(0);
  // Fazemos push de um valor
  int_vec_push(&v, 1); // isto realoca porque capacity(0) == used(0)
  // Criamos um pointer para o primeiro valor do vector
  int* first_value_ptr = &v.values[0];
  // Fazemos push de mais um valor
  int_vec_push(&v, 2); // capacity(1) == used(1) ent√£o realocamos
  // Tentamos alterar o primeiro valor do vector
  *first_value_ptr = 42; // Seg Fault
}
            </code></pre>
            Como podemos ver o <code>first_value</code> passa a ser um dangling
            pointer depois da linha 12, e quando tentamos utiliz√°-lo mais a
            frente o nosso programa crasha.
          </section>
          <section data-auto-animate>
            <pre class="lang-rust" data-id="code-animation">
            <code data-trim data-line-numbers="2|2-5|2-8|2-11|2-14|1-15">
            fn main() {
              let mut v = Vec::new();

              // Fazemos push de um valor
              v.push(1);

              // Criamos um pointer para o primeiro valor do vector
              let first_value_ptr = &mut v[0];

              // Fazemos push de mais um valor
              v.push(2);

              // Tentamos alterar o primeiro valor do vector
              *first_value_ptr = 42;
            }
            </code></pre>
          </section>
          <section data-auto-animate data-background-color="#750b0b">
            <div class="r-stack">
              <pre class="lang-rust" data-id="code-animation">
              <code data-trim data-line-numbers="1-15">
              fn main() {
                let mut v = Vec::new();

                // Fazemos push de um valor
                v.push(1);

                // Criamos um pointer para o primeiro valor do vector
                let first_value_ptr = &mut v[0];

                // Fazemos push de mais um valor
                v.push(2);

                // Tentamos alterar o primeiro valor do vector
                *first_value_ptr = 42;
              }
              </code>
              </pre>
              <img src="img/multiple_mutable_borrows.png" />
            </div>
          </section>
          <section data-auto-animate>
            <div class="r-stack">
              <div style="width:100%">
                <pre class="lang-rust" data-id="code-animation">
                  <code data-trim data-line-numbers="1-11">
                  fn main() {
                    let mut v = Vec::new();
                    // Fazemos push de um valor
                    v.push(1);
                    // Criamos um pointer para o primeiro valor do vector
                    let first_value_ptr = &mut v[0];
                    // Fazemos push de mais um valor
                    v.push(2);
                    // Tentamos alterar o primeiro valor do vector
                    *first_value_ptr = 42;
                  }
                  </code>
                </pre>
                <img src="img/multiple_mutable_borrows_short.png" />
              </div>
              <img class="fragment" src="img/vec_push_signature.png"/>
            </div>
          </section>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
              hash: true,
              // Learn about plugins: https://revealjs.com/plugins/
              plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
            });
    </script>
  </body>
</html>
